#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <errno.h>
#include <fnmatch.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/reg.h>
#include <sys/user.h>
#include <unistd.h>
#include <syscall.h>
#include <signal.h>

void processdir(const struct dirent *dir) {
     puts(dir->d_name);
}


void sys_kill(char* name, int id) {
    printf("Calling sys_Kill...\n");
    sleep(1);
    kill(id, SIGKILL);
    printf("%s has been killed", name);
}


void clearScreen()
{
  printf("\033[2J\033[1;1H");
}


void checkAccess(char* path) {
	 int rval;

	 /* Check file existence. */
	 rval = access (path, F_OK);
	 if (rval == 0) {
	  printf ("%s exists\n", path);
	 } else {
	  	if (errno == ENOENT) 
	  	 	printf ("%s does not exist\n", path);
	  	else if (errno == EACCES) 
	  		printf ("%s is not accessible\n", path);
	 }

	 /* Check read access. */
	 rval = access (path, R_OK);
	 if (rval == 0)
	  	printf ("%s is readable\n", path);
	 else
	  	printf ("%s is not readable (access denied)\n", path);

	 /* Check write access. */
	 rval = access (path, W_OK);
	 if (rval == 0)
	  	printf ("%s is writable\n", path);
	 else if (errno == EACCES)
	  	printf ("%s is not writable (access denied)\n", path);
	 else if (errno == EROFS)
	 	 printf ("%s is not writable (read-only filesystem)\n", path);
}


int filter(const struct dirent *dir) {
     uid_t user;
     struct stat dirinfo;
     int len = strlen(dir->d_name) + 7; 
     char direc[len];

     strcpy(direc, "/proc/");
     strcat(direc, dir->d_name);
     user = getuid();
     if (stat(direc, &dirinfo) < 0) {
	  perror("processdir() ==> stat()");
	  exit(EXIT_FAILURE);
     }
     return !fnmatch("[1-9]*", dir->d_name, 0) && user == dirinfo.st_uid;
}


void translate_Sys_Call(long callNum, char *str) {
	switch(callNum) 
	{
		case 1: 
			str = "SysCall1";
			break;
		case 2: 
			str = "SysCall2";
			break;
		case 3: 
			str = "SysCall3";
			break;
		case 4: 
			str = "SysCall4";
			break;
		case 11: 
			str = "execve";
			break;
		default: 
			sprintf(str, "%ld", callNum);		
	}
}


mode_t select_Mode(int selection) {
	mode_t mode;	
	switch(selection)
	{
		case 1:
			mode = S_ISUID;
		case 2:
			mode = S_ISGID;
		case 3:
			mode = S_ISVTX;
		case 4:
			mode = S_IRUSR;
		case 5:
			mode = S_IWUSR;
		case 6:
			mode = S_IXUSR;
		case 7:
			mode = S_IRGRP;
		case 8:
			mode = S_IWGRP;
		case 9:
			mode = S_IXGRP;
		case 10:
			mode = S_IROTH;
		case 11:
			mode = S_IWOTH;
		case 12:
			mode = S_IXOTH;
	
	}
	return mode;
}


char* get_name_by_pid(const int pid) {
    char* name = (char*)calloc(1024,sizeof(char));
    if(name){
        sprintf(name, "/proc/%d/cmdline",pid);
        FILE* f = fopen(name,"r");
        if(f){
            size_t size;
            size = fread(name, sizeof(char), 1024, f);
            if(size>0){
                if('\n'==name[size-1])
                    name[size-1]='\0';
            }
            fclose(f);
        }
    }
    return name;
}


void scan_processes() {
     struct dirent **namelist;
     int n;
     int y = -1;
     char choice[256];
     char die[256];
     n = scandir("/proc", &namelist, filter, 0);
     int num[n];
     for (int i = 1; i <= n; i++) {
		num[n - i] = i;
     }
     if (n < 0) {
	  	perror("Not enough memory.");
     }

     printf("What would you like to do?\n1) Print list of currently running processes\n2) Search for a specific process name\n3) Kill a process\n4) Back\n");
     scanf("%s", choice);
     if (strcmp(choice, "0") == 1) {
	printf("\n");
     	while(n--) {
		printf("%d) ", num[n]);
		int x = atoi(namelist[n]->d_name);
		printf("%s: ", get_name_by_pid(x));
		processdir(namelist[n]);
		free(namelist[n]);
	}
 	free(namelist);
	getchar();
	getchar();
	printf("\n\n");
	scan_processes();
     }
     else if (strcmp(choice, "1") == 1) {
	char term[256];
	printf("Enter the process name you would like to search for: ");
	scanf("%s", term);
	while(n--) {
		int x = atoi(namelist[n]->d_name);
		if (strcmp(term, get_name_by_pid(x)) == 0) {
			printf("\n%s is a currently running process\n", term);
			free(namelist[n]);
			y = 0;
			break;
		}
		free(namelist[n]);
	}
	if (y == -1) {
		printf("\n%s is not a currently running process\n", term);
	}
	free(namelist);
	getchar();
	getchar();
	printf("\n\n");
	scan_processes();
     }
     else if (strcmp(choice, "2") == 1) {
	printf("Enter the process name or list number you would like to kill: ");
	scanf("%s", die);
	int key = 0;
	while(n--) {
		int x = atoi(namelist[n]->d_name);
		if (strcmp(die, get_name_by_pid(x)) == 0) {
			sys_kill(die, x);
			y = 0;
			break;
		}
		else if (key + 1 == atoi(die)) {
			sys_kill(get_name_by_pid(x), x);
			y = 0;
			break;	
		}
		key++;
	}
	if (y == -1) {
		printf("\n%s is not a currently running process or you entered a number that is out of bounds\n", die);
	}
	free(namelist);
	printf("\n\n");
	getchar();
	getchar();
	scan_processes();
     }
     else if (strcmp(choice, "3") == 1) {
	clearScreen();
     }
     else {
	printf("Please enter a valid input\n\n");
	printf("\n\n");
	scan_processes();
     }
}


void manage_memory() {
     struct dirent **namelist;
     int n;
     int y = -1;
     char choice[256];
     char die[256];
     n = scandir("/proc", &namelist, filter, 0);
     if (n < 0) {
	  	perror("Not enough memory.");
     }

     printf("What would you like to do?\n1) Print list of currently running processes\n2) Print memory mapping of a process\n3) Print memory contents\n4) Back\n");
     scanf("%s", choice);
     if (strcmp(choice, "0") == 1) {
	printf("\n");
     	while(n--) {
		int x = atoi(namelist[n]->d_name);
		printf("%s: ", get_name_by_pid(x));
		processdir(namelist[n]);
		free(namelist[n]);
	}
 	free(namelist);
	getchar();
	getchar();
	printf("\n\n");
	manage_memory();
     }
     else if (strcmp(choice, "1") == 1) {
	printf("Enter process ID whose memory you want to map: ");
	scanf("%s", die);
	char str[50] = "cat /proc/";
	strcat(str, die);
	strcat(str, "/maps");
	system(str);	
	
	free(namelist);
	printf("\n\n");
	getchar();
	getchar();
	manage_memory();
     }
     else if (strcmp(choice, "2") == 1) {
	char addr[64];
	int numWords = 0;
	printf("Enter the memory address, starting with \"0x\": ");
	scanf("%s", addr);
	printf("\n");
	printf("Enter the number of 64-bit words to print: ");
	scanf("%d", &numWords);
	printf("\n");
	int *num = (int*)strtol(addr, NULL, 0);
	void const *data = &num;
	for(int i = 0; i < numWords*8; i+=8) {
		printf("The value at memory address %p is %08X\n", data+i, ((unsigned char*)data)[i]);
	}	
	
	free(namelist);
	printf("\n\n");
	getchar();
	getchar();
	manage_memory();
     }
     else if (strcmp(choice, "3") == 1) {
	clearScreen();
     }
     else {
	printf("Please enter a valid input\n\n");
	printf("\n\n");
	manage_memory();
     }
}


/* 
 *
 * Print System Calls that a process makes
 *
 *
 */

void view_System_Calls() {
     struct dirent **namelist;
     int n;
     int y = -1;
     char choice[256];
     char die[256];
     n = scandir("/proc", &namelist, filter, 0);
     if (n < 0) {
	  	perror("Not enough memory.");
     }

     printf("What would you like to do?\n1) Print list of currently running processes\n2) Print system calls of a process\n3) Back\n");
     scanf("%s", choice);
     if (strcmp(choice, "0") == 1) {
	printf("\n");
     	while(n--) {
		int x = atoi(namelist[n]->d_name);
		printf("%s: ", get_name_by_pid(x));
		processdir(namelist[n]);
		free(namelist[n]);
	}
 	free(namelist);
	getchar();
	getchar();
	printf("\n\n");
	view_System_Calls();
     }
     else if (strcmp(choice, "1") == 1) {
	printf("Enter process ID whose system calls you want to track: ");
	scanf("%s", die);
	//char str[50] = "/proc/";
	//strcat(str, die);
	//strcat(str, "/syscall");
	//system(str);	
	//ptrace(PTRACE_foo, getpid());

	pid_t child;
    	long orig_eax;
    	child = fork();
	char callName[256];

   	 if(child == 0) {
        	ptrace(PTRACE_TRACEME, 0, NULL, NULL);
        	execl("/bin/ls", "ls", NULL);
    	}
   	 else {
       	 	wait(NULL);
        	orig_eax = ptrace(PTRACE_PEEKUSER, child, 4 * ORIG_RAX, NULL);
		translate_Sys_Call(orig_eax, callName);
        	printf("The child made a system call %s\n", callName);
        	ptrace(PTRACE_CONT, child, NULL, NULL);
    	}
	
	free(namelist);
	printf("\n\n");
	getchar();
	getchar();
	view_System_Calls();
     }
     else if (strcmp(choice, "2") == 1) {
	clearScreen();
     }
     else {
	printf("Please enter a valid input\n\n");
	printf("\n\n");
	view_System_Calls();
     }
}


void manage_Permissions() {
     struct dirent **namelist;
     int n;
     int y = -1;
     int modeChoice;
     char choice[256];
     char input[256];
     n = scandir("/proc", &namelist, filter, 0);
     if (n < 0) {
	  	perror("Not enough memory.");
     }

     	printf("What would you like to do?\n1) Print currect directory contents\n2) Change a file's permissions\n3) Back\n");
     	scanf("%s", choice);
	printf("\n");
     	if (strcmp(choice, "0") == 1) {
		pid_t child;
		child = fork();
   		if(child == 0) {
        		execl("/bin/ls", "ls", NULL);
			printf("\n");
    		} else {
			wait(NULL);
			printf("\n");
			manage_Permissions();			
		}		
    	}
	else if(strcmp(choice, "1") == 1) {
		printf("Enter the filepath: ");
		scanf("%s", input);
		checkAccess(input);
		printf("\n");
		printf("\nWhat mode would you like to change to?\n");
		printf("1 - Set User ID: Set process user ID on execve\n");
		printf("2 - Set Group ID: Set process group ID on execve\n");
		printf("3 - Sticky Bit: Unrestricted deletion bit\n");
		printf("4 - Read by Owner\n");
		printf("5 - Write by Owner\n");
		printf("6 - Execute/Search by Owner: Search applies to directories, means files in directory can be accessed\n");
		printf("7 - Read by Group\n");
		printf("8 - Write by Group\n");
		printf("9 - Execute/Search by Group\n");
		printf("10 - Read by Others\n");
		printf("11 - Write by Others\n");
		printf("12 - Execute/Search by Others\n");
		scanf("%d", &modeChoice);
		mode_t selMode = select_Mode(modeChoice);  
		chmod(input, selMode);
		checkAccess(input);
		printf("\n");
		manage_Permissions();		
	}
	 else if (strcmp(choice, "2") == 1) {
	  	clearScreen();
        }
        else {
		printf("Please enter a valid input\n\n");
		printf("\n\n");
		manage_Permissions();
        }
}
 

int main() {
     char choice[256] = "6";
     while (strcmp(choice,"5") != 0) {
     	printf("Choose one of the following options:\n");
     	printf("1) Scan list of processes\n2) Scan memory\n3) Scan system call table\n4) Manage File/Directory Permissions\n5) Exit\n");
     	scanf("%s", choice);
     	if (strcmp(choice, "0") == 1) {
		clearScreen();
		scan_processes();
	}
	else if (strcmp(choice, "1") == 1) {
		clearScreen();		
		manage_memory();
	}
	else if (strcmp(choice, "2") == 1) {
		clearScreen();
		view_System_Calls();
	}
	else if (strcmp(choice, "3") == 1) {
		clearScreen();		
		manage_Permissions();
	}
	else if(strcmp(choice, "4") == 1) {
		printf("Exiting...\n");
	}
	else {
		printf("Please enter a valid input\n\n");
	}
     }
     return 0;
}

